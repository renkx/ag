user nginx;

# 启动进程,通常设置成和cpu的数量相等
worker_processes auto;

# CPU 亲和性配置, 自动即可
worker_cpu_affinity auto;

# 配置Nginx worker进程最大打开文件数
worker_rlimit_nofile 65535;

# 全局错误日志
# 官方nginx镜像的 /var/log/nginx/error.log 文件与 /dev/stderr 建立了软连接
# 改为 error_docker.log 是需要宿主机挂载
error_log /var/log/nginx/error_docker.log error;

# 工作模式及连接数上限
events {
    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,
    #仅用于linux2.6以上内核,可以大大提高nginx的性能
    use epoll;
    # 事件驱动模块 use epoll时配置
    #epoll_events 1024; # 默认值为 512，即每次事件循环最多处理 512 个事件。
    #epoll_event_connections 2048; # 默认值为 2048，即每个事件最多处理 2048 个连接。
    #epoll_timeout 0; # 默认值为 0，即 epoll 模块不会超时，等待事件的时间取决于操作系统。
    #单个后台worker process进程的最大并发链接数
    worker_connections 65535;
}

http {
    # 设定mime类型,类型由mime.type文件定义
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 隐藏版本号
    server_tokens off;

    # Specifies the maximum accepted body size of a client request, as
    # indicated by the request header Content-Length. If the stated content
    # length is greater than this size, then the client receives the HTTP
    # error code 413. Set to 0 to disable. Default is '1m'.
    # 设置NGINX能处理的最大请求主体大小。 如果请求大于指定的大小，则NGINX发回HTTP 413（Request Entity too large）错误。
    # 如果服务器处理大文件上传，则该指令非常重要
    client_max_body_size 5m;
    # 保存服务器名字的hash表是由指令 server_names_hash_max_size 和 server_names_hash_bucket_size所控制的
    server_names_hash_bucket_size 512;
    # client_header_buffer_size 为请求头分配一个缓冲区。 如果请求头大小大于指定的缓冲区，
    # 则使用large_client_header_buffers指令分配更大的缓冲区
    client_header_buffer_size 32k;

    # 下面两个指令新版nginx里已经被废弃了
    # http2_max_field_size 16k;
    # http2_max_header_size 32k;
    # 这两个参数分别代表：缓冲区的数量 和 每个缓冲区的大小
    # 32k 对应你之前的 field_size，4个缓冲区足够处理极大的 Header
    # 规定了用于读取大型客户端请求头的缓冲区的最大数量和大小
    large_client_header_buffers 4 32k;
    # 限制每个 HTTP/2 连接同时处理的请求数，防止瞬时并发太高导致 TLS 记录乱序
    http2_max_concurrent_streams 64;

    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
    #对于普通应用，必须设为 on,
    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，
    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.
    sendfile on;

    # Causes nginx to attempt to send its HTTP response head in one packet,
    # instead of using partial frames. Default is 'off'.
    tcp_nopush on;
    # 对于 Web 服务，通常建议开启。它能禁用 Nagle 算法，让小数据包（如 TLS 握手包）立即发送，降低延迟
    tcp_nodelay on;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 5;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # Enables the specified protocols. Default is TLSv1 TLSv1.1 TLSv1.2.
    # TIP: If you're not obligated to support ancient clients, remove TLSv1.1.
    ssl_protocols TLSv1.2 TLSv1.3;

    # Enables a shared SSL cache with size that can hold around 8000 sessions.
    # Default is 'none'.
    ssl_session_cache shared:SSL:10m;

    # Specifies a time during which a client may reuse the session parameters.
    # Default is '5m'.
    ssl_session_timeout 1d;

    # Disable TLS session tickets (they are insecure). Default is 'on'.
    ssl_session_tickets off;

    # 设定日志格式 (HTTP)
    log_format json_http escape=json '{'
        # --- 基础元数据 ---
        '"log_type": "http_access",'
        '"time": "$time_iso8601",'             # ISO8601格式 (2026-01-21T12:00:00+08:00)，易读且易排序
        '"status": "$status",'                  # HTTP状态码 (如 200, 404, 502)
        '"http_protocol": "$server_protocol",'  # 协议版本 (如 HTTP/1.1, HTTP/2.0)

        # --- 请求身份与位置 ---
        '"host": "$host",'                      # 请求的域名
        '"server_port": "$server_port",'        # 服务器监听端口
        '"request": "$request",'                # 完整的请求行 (例如: POST /api/v1/user HTTP/2.0)
        '"remote_addr": "$remote_addr",'        # 客户端直连IP
        '"remote_user": "$remote_user",'        # 认证用户名 (如果有)

        # --- 客户端指纹 ---
        '"http_user_agent": "$http_user_agent",' # 用户代理 (浏览器/客户端标识)
        '"http_referrer": "$http_referer",'      # 来源页面

        # --- 性能指标 (排查慢请求用) ---
        '"request_time": "$request_time",'                     # 请求处理总耗时 (秒)
        '"upstream_response_time": "$upstream_response_time",' # 后端(Upstream)响应耗时
        '"body_bytes_sent": "$body_bytes_sent",'               # 发送给客户端的响应体大小 (字节)

        # --- 代理链路追踪 (穿透多层代理用) ---
        '"proxy_protocol_addr": "$proxy_protocol_addr",'       # 通过 PROXY 协议获取的原始 IP
        '"http_x_forwarded_for": "$http_x_forwarded_for",'     # X-Forwarded-For 头部
        '"forwarded_detail": "$proxy_add_forwarded"'           # 组合后的 Forwarded 详情
    '}';

    # 官方nginx镜像的 /var/log/nginx/access.log 文件与 /dev/stdout 建立了软连接
    # 没 flush 秒 写一次日志，可以极大降低 CPU 和 I/O 压力
    # 改为 access_docker.log 是需要宿主机挂载
    access_log /var/log/nginx/access_docker.log json_http buffer=32k flush=5s;

    keepalive_timeout 75s;

    # 设置Nginx代理服务器从实际服务器接收到响应数据时的缓冲区的大小，默认是4k|8k（根据系统处理）
    # 简单理解：Nginx代理服务器时，在接收到实际服务器的响应时，它会在自身搞出个缓冲区去放置，而这个缓冲区的默认大小是4k或者8k.(后来查了下，我的接口请求的响应大小在28k,远远超出了这个上限)
    proxy_buffer_size 128k;
    proxy_buffers 32 64k;
    # nginx会在没有完全读完后端响应就开始向客户端传送数据，所以它会划出一部分busy状态的buffer来专门向客户端传送数据(建议为proxy_buffers中单个缓冲区的2倍)，然后它继续从后端取数据。
    proxy_busy_buffers_size 128k;

    #map指令的作用：
    #根据客户端请求中$http_upgrade 的值，来构造改变$connection_upgrade的值
    #即根据变量$http_upgrade的值创建新的变量$connection_upgrade，
    #创建的规则就是{}里面的东西。其中的规则没有做匹配，因此使用默认的.
    #即 $connection_upgrade 的值会一直是 upgrade。然后如果 $http_upgrade为空字符串的话，
    #那值会是 close。
    #进行特殊的配置才能支持websocket
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # 这个块的作用是根据 $proxy_protocol_addr（通过 PROXY 协议获取的客户端 IP）的格式，将其转换成 Forwarded 指令要求的格式
    map $proxy_protocol_addr $proxy_forwarded {
        # 如果是 IPv4，直接显示
        ~^[0-9.]+$        "for=$proxy_protocol_addr";
        # 如果是 IPv6，按规定加方括号和引号
        ~^[0-9A-Fa-f:.]+$ "for=\"[$proxy_protocol_addr]\"";
        # 无法识别时显示 unknown
        default           "for=unknown";
    }

    # 这个块的作用是检查请求中是否已经存在 Forwarded 头部。如果有，就将新的信息追加在后面；如果没有，就创建一个新的
    map $http_forwarded $proxy_add_forwarded {
        # 正则表达式的作用：验证原始的 $http_forwarded 是否符合 RFC 7239 的语法标准。如果符合，Nginx 就会执行 $http_forwarded, $proxy_forwarded，用逗号把新旧信息连起来
        "~^(,[ \\t]*)*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*([ \\t]*,([ \\t]*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*)?)*$" "$http_forwarded, $proxy_forwarded";
        # 否则，只使用当前获取的信息
        default "$proxy_forwarded";
    }

    # Includes virtual hosts configs.
	include /etc/nginx/conf.d/http.conf;
}

# TIP: Uncomment if you use stream module.
#include /etc/nginx/stream.conf;
stream {
    # 设定日志格式 (TCP/UDP Stream)
    log_format json_stream escape=json '{'
        # --- 基础元数据 ---
        '"log_type": "stream_access",'
        '"time": "$time_iso8601",'             # 推荐：ISO8601格式
        '"status": "$status",'                  # 连接状态 (如 200, 500)
        '"protocol": "$protocol",'              # 协议类型 (TCP 或 UDP)

        # --- 连接信息 ---
        '"remote_addr": "$remote_addr",'        # 客户端IP
        '"server_port": "$server_port",'        # 本地监听端口 (重要：区分不同业务流)
        '"session_time": "$session_time",'      # 连接保持时长 (秒)

        # --- 流量统计 ---
        '"bytes_sent": "$bytes_sent",'          # 发送给客户端的字节数
        '"bytes_received": "$bytes_received",'  # 从客户端接收的字节数

        # --- 后端转发详情 (嵌套对象) ---
        '"upstream": {'
            '"addr": "$upstream_addr",'                 # 转发到的后端地址
            '"bytes_sent": "$upstream_bytes_sent",'     # 发送给后端的字节
            '"bytes_received": "$upstream_bytes_received",' # 从后端接收的字节
            '"connect_time": "$upstream_connect_time"'  # 连接后端耗时
        '},'

        # --- SSL 握手详情 (嵌套对象) ---
        # 其他变量会调用相关组件消耗性能
        '"ssl": {'
            '"preread_server_name": "$ssl_preread_server_name",' # SSL Client Hello 中的 SNI 域名 (非解密流量也能看到域名)
            '"preread_protocol": "$ssl_preread_protocol",'       # 预读取的协议版本
            '"alpn_protocol": "$ssl_alpn_protocol"'             # ALPN 协商结果
        '}'
    '}';

    # 官方nginx镜像的 /var/log/nginx/access.log 文件与 /dev/stdout 建立了软连接
    # 没 flush 秒 写一次日志，可以极大降低 CPU 和 I/O 压力
    # 改为 access_docker.log 是需要宿主机挂载
    access_log /var/log/nginx/access_docker.log json_stream buffer=32k flush=5s;

    # 当使用map模块的哈希表时，可以使用map_hash_bucket_size配置指定哈希表的桶大小
	map_hash_bucket_size 256;

	# 域名解析超时时间 默认30s
	resolver_timeout 2s;

    # 启用 TCP_NODELAY 可以减少小包传输的延迟（类似 buffering off 的初衷）
    tcp_nodelay on;

    # 确保缓冲区足够容纳一个 TLS Record
    proxy_buffer_size 128k;

    # 自定义stream模块配置
    include /etc/nginx/conf.d/stream.conf;
}
